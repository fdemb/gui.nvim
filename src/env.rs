//! Environment variable capture and loading.
//!
//! This module provides functionality similar to Doom Emacs's `doom env` command.
//! When launched from a terminal, `gui.nvim env` captures the current shell's
//! environment variables to a config file. On subsequent launches (e.g., from
//! Finder/Spotlight), these variables are loaded before spawning Neovim.
//!
//! This is essential on macOS where GUI apps don't inherit shell environment,
//! breaking version managers (nvm, rbenv, pyenv, mise, asdf) and custom PATHs.

use std::collections::HashMap;
use std::fs::{self, File};
use std::io::{BufRead, BufReader, Write};
use std::path::PathBuf;

/// Environment variables to exclude from capture.
/// These are either security-sensitive or session-specific.
const EXCLUDED_VARS: &[&str] = &[
    // Security sensitive
    "SSH_AUTH_SOCK",
    "SSH_AGENT_PID",
    "GPG_AGENT_INFO",
    "GNOME_KEYRING_CONTROL",
    "GNOME_KEYRING_PID",
    // Session specific
    "TERM_SESSION_ID",
    "TERM_PROGRAM",
    "TERM_PROGRAM_VERSION",
    "ITERM_SESSION_ID",
    "ITERM_PROFILE",
    "COLORTERM",
    "TERM",
    "TMPDIR",
    "SHELL_SESSION_ID",
    "Apple_PubSub_Socket_Render",
    "SECURITYSESSIONID",
    // Display specific (will be set by the app)
    "DISPLAY",
    "WAYLAND_DISPLAY",
    // Process specific
    "SHLVL",
    "_",
    "PWD",
    "OLDPWD",
    // gui-nvim specific (avoid recursion)
    "GUI_NVIM_ENV_LOADED",
    // Terminal emulator specific
    "KITTY_PID",
    "KITTY_PUBLIC_KEY",
    "KITTY_WINDOW_ID",
    "WINDOWID",
    "TERMINFO",
    "KITTY_INSTALLATION_DIR",
    // Agent/session specific
    "AGENT",
    "XPC_SERVICE_NAME",
    "XPC_FLAGS",
    // Build tools (when running from cargo)
    "CARGO",
];

/// Prefixes of environment variables to exclude.
/// Variables starting with these prefixes are build-time or runtime specific.
const EXCLUDED_PREFIXES: &[&str] = &[
    "CARGO_",     // Cargo build variables
    "LD_",        // Linker variables
    "DYLD_",      // macOS dynamic linker
    "__CF",       // Core Foundation internals
    "__CFBUNDLE", // Bundle internals
    "__MISE_",    // Mise internals
    "OPENCODE_",  // OpenCode agent vars
    "OSLog",      // macOS logging
];

/// Suffixes of environment variables to exclude (likely secrets).
const EXCLUDED_SUFFIXES: &[&str] = &[
    "_KEY",
    "_SECRET",
    "_TOKEN",
    "_PASSWORD",
    "_CREDENTIAL",
    "_API_KEY",
];

/// Returns the path to the environment file.
/// Location: `~/.config/gui-nvim/env`
pub fn env_file_path() -> Option<PathBuf> {
    dirs_next().map(|p| p.join("env"))
}

/// Returns the gui-nvim config directory.
/// Location: `~/.config/gui-nvim/`
fn dirs_next() -> Option<PathBuf> {
    if let Some(config_dir) = std::env::var_os("XDG_CONFIG_HOME") {
        Some(PathBuf::from(config_dir).join("gui-nvim"))
    } else if let Some(home) = std::env::var_os("HOME") {
        Some(PathBuf::from(home).join(".config").join("gui-nvim"))
    } else {
        None
    }
}

/// Captures current environment variables to the config file.
///
/// Returns the number of variables captured.
pub fn dump_env() -> Result<usize, EnvError> {
    let path = env_file_path().ok_or(EnvError::NoConfigDir)?;

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut file = File::create(&path)?;

    // Write header
    writeln!(file, "# gui.nvim environment file")?;
    writeln!(file, "# Generated by `gui.nvim env`")?;
    writeln!(file, "# Re-run this command from your shell to update")?;
    writeln!(file, "#")?;
    writeln!(
        file,
        "# This file is loaded on startup when launching from Finder/Spotlight"
    )?;
    writeln!(
        file,
        "# to ensure Neovim has access to your shell's PATH and other variables."
    )?;
    writeln!(file)?;

    let mut count = 0;
    let mut vars: Vec<_> = std::env::vars().collect();
    vars.sort_by(|a, b| a.0.cmp(&b.0));

    for (key, value) in vars {
        // Skip excluded variables
        if EXCLUDED_VARS.contains(&key.as_str()) {
            continue;
        }

        // Skip variables with excluded prefixes
        if EXCLUDED_PREFIXES
            .iter()
            .any(|prefix| key.starts_with(prefix))
        {
            continue;
        }

        // Skip variables with excluded suffixes (likely secrets)
        if EXCLUDED_SUFFIXES.iter().any(|suffix| key.ends_with(suffix)) {
            continue;
        }

        // Skip empty values
        if value.is_empty() {
            continue;
        }

        // Skip variables with excluded prefixes
        if EXCLUDED_PREFIXES
            .iter()
            .any(|prefix| key.starts_with(prefix))
        {
            continue;
        }

        // Skip empty values
        if value.is_empty() {
            continue;
        }

        // Write in KEY=VALUE format, escaping newlines
        let escaped = value.replace('\n', "\\n").replace('\r', "\\r");
        writeln!(file, "{}={}", key, escaped)?;
        count += 1;
    }

    log::info!("Wrote {} environment variables to {:?}", count, path);
    Ok(count)
}

/// Loads environment variables from the config file into the current process.
///
/// Returns the number of variables loaded, or None if the file doesn't exist.
pub fn load_env() -> Result<Option<usize>, EnvError> {
    // Don't load if we've already loaded (prevents double-loading)
    if std::env::var("GUI_NVIM_ENV_LOADED").is_ok() {
        log::debug!("Environment already loaded, skipping");
        return Ok(None);
    }

    let path = match env_file_path() {
        Some(p) if p.exists() => p,
        _ => return Ok(None),
    };

    let file = File::open(&path)?;
    let reader = BufReader::new(file);

    let mut count = 0;
    for line in reader.lines() {
        let line = line?;

        // Skip comments and empty lines
        if line.starts_with('#') || line.trim().is_empty() {
            continue;
        }

        // Parse KEY=VALUE
        if let Some(eq_pos) = line.find('=') {
            let key = &line[..eq_pos];
            let value = &line[eq_pos + 1..];

            // Unescape newlines
            let unescaped = value.replace("\\n", "\n").replace("\\r", "\r");

            std::env::set_var(key, &unescaped);
            count += 1;
        }
    }

    // Mark as loaded to prevent double-loading
    std::env::set_var("GUI_NVIM_ENV_LOADED", "1");

    log::info!("Loaded {} environment variables from {:?}", count, path);
    Ok(Some(count))
}

/// Returns the captured environment as a HashMap for passing to child processes.
#[allow(dead_code)]
pub fn get_env_map() -> HashMap<String, String> {
    std::env::vars().collect()
}

#[derive(Debug, thiserror::Error)]
pub enum EnvError {
    #[error("Could not determine config directory")]
    NoConfigDir,
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_excluded_vars_not_empty() {
        assert!(!EXCLUDED_VARS.is_empty());
    }

    #[test]
    fn test_env_file_path() {
        // Should return Some on most systems
        let path = env_file_path();
        if let Some(p) = path {
            assert!(p.ends_with("gui-nvim/env"));
        }
    }

    #[test]
    fn test_escape_newlines() {
        let value = "line1\nline2\rline3";
        let escaped = value.replace('\n', "\\n").replace('\r', "\\r");
        assert_eq!(escaped, "line1\\nline2\\rline3");

        let unescaped = escaped.replace("\\n", "\n").replace("\\r", "\r");
        assert_eq!(unescaped, value);
    }
}
